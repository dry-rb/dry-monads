

module Dry
  module Monads
    # Validated is similar to Result and represents an outcome of a validation.
    # The difference between Validated and Result is that the former implements
    # `#apply` in a way that concatenates errors. This means that the error type
    # has to have `+` implemented (be a semigroup). This plays nice with arrays and lists.
    # Also, List<Validated>#traverse implicitly uses a block that wraps errors with
    # a list so that you don't have to do it manually.
    #
    # @example using with List
    #   List::Validated[Valid('London'), Invalid(:name_missing), Invalid(:email_missing)]
    #   # => Invalid(List[:name_missing, :email_missing])
    #
    # @example with valid results
    #   List::Validated[Valid('London'), Valid('John')]
    #   # => Valid(List['London', 'John'])
    class Validated
      # Wraps a value with `Valid`.
      #
      # @overload pure(value)
      #   @param value [Object] value to be wrapped with Valid
      #   @return [Validated::Valid]
      #
      # @overload pure(&block)
      #   @param block [Object] block to be wrapped with Valid
      #   @return [Validated::Valid]
      def self.pure: (?untyped value) ?{ (?) -> untyped } -> untyped

      # Returns self.
      #
      # @return [Validated::Valid, Validated::Invalid]
      def to_monad: () -> untyped

      # Bind/flat_map is not implemented
      def bind: () -> untyped

      # Valid result
      class Valid < Validated
        def initialize: (untyped value) -> untyped

        # Extracts the value
        #
        # @return [Object]
        def value!: () -> untyped

        # Applies another Valid to the stored function
        #
        # @overload apply(val)
        #   @example
        #     Validated.pure { |x| x + 1 }.apply(Valid(2)) # => Valid(3)
        #
        #   @param val [Validated::Valid,Validated::Invalid]
        #   @return [Validated::Valid,Validated::Invalid]
        #
        # @overload apply
        #   @example
        #     Validated.pure { |x| x + 1 }.apply { Valid(4) } # => Valid(5)
        #
        #   @yieldreturn [Validated::Valid,Validated::Invalid]
        #   @return [Validated::Valid,Validated::Invalid]
        def apply: (?untyped val) ?{ (?) -> untyped } -> untyped

        # Lifts a block/proc over Valid
        #
        # @overload fmap(proc)
        #   @param proc [#call]
        #   @return [Validated::Valid]
        #
        # @overload fmap
        #   @param block [Proc]
        #   @return [Validated::Valid]
        def fmap: (?untyped proc) ?{ (?) -> untyped } -> untyped

        # Ignores values and returns self, see {Invalid#alt_map}
        #
        # @return [Validated::Valid]
        def alt_map: (?untyped _) ?{ (?) -> untyped } -> untyped

        # Ignores arguments, returns self
        #
        # @return [Validated::Valid]
        def or: (?untyped _) ?{ (?) -> untyped } -> untyped

        # @return [String]
        def inspect: () -> untyped

        # @param other [Object]
        # @return [Boolean]
        def ===: (untyped other) -> untyped
      end

      # Invalid result
      class Invalid < Validated
        # The value stored inside
        #
        # @return [Object]
        attr_reader error: untyped

        # Line where the value was constructed
        #
        # @return [String]
        # @api public
        attr_reader trace: untyped

        def initialize: (untyped error, ?untyped trace) -> untyped

        # Collects errors (ignores valid results)
        #
        # @overload apply(val)
        #   @param val [Validated::Valid,Validated::Invalid]
        #   @return [Validated::Invalid]
        #
        # @overload apply
        #   @yieldreturn [Validated::Valid,Validated::Invalid]
        #   @return [Validated::Invalid]
        def apply: (?untyped val) ?{ (?) -> untyped } -> untyped

        # Lifts a block/proc over Invalid
        #
        # @overload alt_map(proc)
        #   @param proc [#call]
        #   @return [Validated::Invalid]
        #
        # @overload alt_map
        #   @param block [Proc]
        #   @return [Validated::Invalid]
        def alt_map: (?untyped proc) ?{ (?) -> untyped } -> untyped

        # Ignores the passed argument and returns self
        #
        # @return [Validated::Invalid]
        def fmap: (?untyped _) ?{ (?) -> untyped } -> untyped

        # Yields the given callable and returns the result
        #
        # @overload or(proc)
        #   @param proc [#call]
        #   @return [Object]
        #
        # @overload or
        #   @param block [Proc]
        #   @return [Object]
        def or: (?untyped proc) ?{ (?) -> untyped } -> untyped

        # @return [String]
        def inspect: () -> untyped

        # @param other [Object]
        # @return [Boolean]
        def ===: (untyped other) -> untyped
      end

      # Mixin with Validated constructors
      module Mixin
        # Successful validation result
        # @see Dry::Monads::Validated::Valid
        Valid: untyped

        # Unsuccessful validation result
        # @see Dry::Monads::Validated::Invalid
        Invalid: untyped

        # Actual constructor methods
        module Constructors
          # Valid constructor
          #
          # @overload Valid(value)
          #   @param value [Object]
          #   @return [Valdated::Valid]
          #
          # @overload Valid(&block)
          #   @param block [Proc]
          #   @return [Valdated::Valid]
          def Valid: (?untyped value) ?{ (?) -> untyped } -> untyped

          # Invalid constructor
          #
          # @overload Invalid(value)
          #   @param value [Object]
          #   @return [Valdated::Invalid]
          #
          # @overload Invalid(&block)
          #   @param block [Proc]
          #   @return [Valdated::Invalid]
          def Invalid: (?untyped value) ?{ (?) -> untyped } -> untyped
        end

        include Constructors
      end
    end

    extend Validated::Mixin::Constructors

    # @see Validated::Valid
    Valid: untyped

    # @see Validated::Invalid
    Invalid: untyped

    class Result
      class Success < Result
        # Transforms to Validated
        #
        # @return [Validated::Valid]
        def to_validated: () -> untyped
      end

      class Failure < Result
        # Transforms to Validated
        #
        # @return [Validated::Invalid]
        def to_validated: () -> untyped
      end
    end
  end
end

